<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ThreeJs Testing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="../build/three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            const COUNTER_MAX = 100;
            const COUNTER_MAX2 = 170;
            const MAX_SPEED = 200;
            
            const width = 6000;
            const height = 6000;
            
            var colorCounter = 0;
            
			var container, stats;

			var camera, scene, renderer;
            
            var id;
            
            var colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0x00ffff, 0xff00ff, 0x800000, 0x008000, 0x000080, 0x808000, 0x800080, 0x008080];
            
            function Player(id, radius, locationX, locationZ, vectorX, vectorZ, color, status, obj) {
                var newObj = {};
                newObj.id = id;
                newObj.radius = radius;
                newObj.locationX = locationX;
                newObj.locationZ = locationZ;
                newObj.vectorX = vectorX;
                newObj.vectorZ = vectorZ;
                newObj.color = color;
                newObj.status = status;
                newObj.obj = obj;
                
                return newObj;
            }
            
            
            var playerList = [Player(1, 150, 3000, 3000, 500, 840, colors[colorCounter++ % colors.length], null, null), 
                              Player(2, 150, 3000, 3000, -600, -450, colors[colorCounter++ % colors.length], null, null), 
                              Player(3, 150, 3000, 3000, -400, 610, colors[colorCounter++ % colors.length], null, null),
                              Player(4, 150, 3000, 3000, 600, 550, colors[colorCounter++ % colors.length], null, null), 
                              Player(5, 150, 3000, 3000, 1300, 820, colors[colorCounter++ % colors.length], null, null), 
                              Player(6, 150, 3000, 3000, -350, 750, colors[colorCounter++ % colors.length], null, null), 
                              Player(7, 150, 3000, 3000, -500, -850, colors[colorCounter++ % colors.length], null, null), 
                              Player(8, 150, 3000, 3000, 300, 750, colors[colorCounter++ % colors.length], null, null), 
                         ];
            
            

            var radius = 50;
            
            var timer = Date.now();

			init();
			animate();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, 1, 1, 20000 );
                
                
//                camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
                camera.position.set(000, 8000, 0);
                camera.up = new THREE.Vector3(0, 0, 1);
				

				scene = new THREE.Scene();

				var light, object;

				scene.add( new THREE.AmbientLight( 0x404040 ) );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1, 0 );
				scene.add( light );

				var map = new THREE.TextureLoader().load( 'textures/UV_Grid_Sm.jpg' );
//                var map = new THREE.TextureLoader().load( 'textures/lensflare2.jpg' );
//                var map = new THREE.TextureLoader().load( 'textures/sprite0.png' );
//                var map = new THREE.TextureLoader().load( 'textures/envmap.png' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

                playerList.forEach(function(element) {
                    console.log("FOREACH ONE TIME ON TEST");
                    var newMaterial = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );
                    newMaterial.color.setHex(element.color);
                    
                    element.obj = new THREE.Mesh( new THREE.SphereGeometry( element.radius, 20, 0, Math.PI * 2 ), newMaterial );
                    element.obj.position.set(element.locationX, 0, element.locationZ);
                    scene.add(element.obj);
                });
                

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );


				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function animate() {
                var deltaTime = (Date.now() - timer) / 1000.0;
                timer = Date.now();
                
				requestAnimationFrame( animate );

                updatePlayers(deltaTime);
                
				render();
				stats.update();

			}
            
            
            function updatePlayers(deltaTime) {
                playerList.forEach(function(element) {
                    if (element.obj.position.z + radius + element.vectorZ * deltaTime > height ||
                       element.obj.position.z - radius + element.vectorZ * deltaTime < 0) {
                            console.log("position z: " + element.obj.position.z + ", vectorZ: " + element.vectorZ);
                            element.vectorZ *= -1;
                    } 
                
                    if (element.obj.position.x - radius + element.vectorX * deltaTime < 0 ||
                        element.obj.position.x + radius + element.vectorX * deltaTime > width) {
                            element.vectorX *= -1;
                    }
                    
                    
                    element.obj.position.x += element.vectorX * deltaTime;
                    element.obj.position.z += element.vectorZ * deltaTime;
                });
            }

			function render() {
//                camera.lookAt(new THREE.Vector3(0,0,0));
                camera.lookAt(new THREE.Vector3(width / 2, 0, height / 2));
//                
//                var vFOV = camera.fov * Math.PI / 180;        // convert vertical fov to radians
//                var height = 2 * Math.tan( vFOV / 2 ) * 370; // visible height
//
//                var aspect = window.width / window.height;
//                var width = height * aspect;                  // visible width
//                
//                console.log("height: " + height);
//                console.log("width: " + width);

				for ( var i = 0, l = scene.children.length; i < l; i ++ ) {

					var object = scene.children[ i ];

//					object.rotation.x = -90;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
